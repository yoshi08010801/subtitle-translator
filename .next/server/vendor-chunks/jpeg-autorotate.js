/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jpeg-autorotate";
exports.ids = ["vendor-chunks/jpeg-autorotate"];
exports.modules = {

/***/ "(ssr)/./node_modules/jpeg-autorotate/src/customerror.js":
/*!*********************************************************!*\
  !*** ./node_modules/jpeg-autorotate/src/customerror.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("const m = function (code, message, buffer = null) {\n  this.code = code\n  this.message = message\n  this.buffer = buffer\n  this.stack = new Error().stack\n}\nm.prototype = Object.create(Error.prototype)\nm.prototype.constructor = m\n\nmodule.exports = m\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanBlZy1hdXRvcm90YXRlL3NyYy9jdXN0b21lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMveW9zaGkvRGVza3RvcC9zdWJ0aXRsZS10cmFuc2xhdG9yL25vZGVfbW9kdWxlcy9qcGVnLWF1dG9yb3RhdGUvc3JjL2N1c3RvbWVycm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG0gPSBmdW5jdGlvbiAoY29kZSwgbWVzc2FnZSwgYnVmZmVyID0gbnVsbCkge1xuICB0aGlzLmNvZGUgPSBjb2RlXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgdGhpcy5idWZmZXIgPSBidWZmZXJcbiAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrXG59XG5tLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxubS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtXG5cbm1vZHVsZS5leHBvcnRzID0gbVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jpeg-autorotate/src/customerror.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jpeg-autorotate/src/main.js":
/*!**************************************************!*\
  !*** ./node_modules/jpeg-autorotate/src/main.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const CustomError = __webpack_require__(/*! ./customerror.js */ \"(ssr)/./node_modules/jpeg-autorotate/src/customerror.js\")\nconst rotateBuffer = (__webpack_require__(/*! ./transform.js */ \"(ssr)/./node_modules/jpeg-autorotate/src/transform.js\").rotateBuffer)\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst piexif = __webpack_require__(/*! piexifjs */ \"(ssr)/./node_modules/piexifjs/piexif.js\")\nconst promisify = (__webpack_require__(/*! util */ \"util\").promisify)\n\nconst m = {}\n\nm.errors = {\n  read_file: 'read_file',\n  read_exif: 'read_exif',\n  no_orientation: 'no_orientation',\n  unknown_orientation: 'unknown_orientation',\n  correct_orientation: 'correct_orientation',\n  rotate_file: 'rotate_file',\n}\n\n/**\n * Read the input, rotate the image, return the result (updated buffer, dimensions, etc)\n */\nm.rotate = function (pathOrBuffer, opts, callback) {\n  const hasCallback = typeof callback === 'function'\n  const quality =\n    typeof opts === 'object' &&\n    opts !== null &&\n    typeof opts.quality === 'number' &&\n    opts.quality > 0 &&\n    opts.quality <= 100\n      ? opts.quality\n      : 100\n  const maxResolutionInMP =\n    typeof opts === 'object' &&\n    opts !== null &&\n    typeof opts.jpegjsMaxResolutionInMP === 'number' &&\n    opts.jpegjsMaxResolutionInMP > 0\n      ? opts.jpegjsMaxResolutionInMP\n      : null\n  const maxMemoryUsageInMB =\n    typeof opts === 'object' &&\n    opts !== null &&\n    typeof opts.jpegjsMaxMemoryUsageInMB === 'number' &&\n    opts.jpegjsMaxMemoryUsageInMB > 0\n      ? opts.jpegjsMaxMemoryUsageInMB\n      : null\n  const promise = readBuffer(pathOrBuffer)\n    .then(readExifFromBuffer)\n    .then(({buffer, exifData}) => {\n      const orientation = parseOrientationTag({buffer, exifData})\n      return Promise.all([\n        rotateImage(buffer, orientation, quality, maxResolutionInMP, maxMemoryUsageInMB),\n        rotateThumbnail(buffer, exifData, orientation, quality, maxResolutionInMP, maxMemoryUsageInMB),\n      ]).then(([image, thumbnail]) => {\n        return computeFinalBuffer(image, thumbnail, exifData, orientation)\n      })\n    })\n    .then(({updatedBuffer, orientation, updatedDimensions}) => {\n      if (!hasCallback) {\n        return {buffer: updatedBuffer, orientation, dimensions: updatedDimensions, quality}\n      }\n      callback(null, updatedBuffer, orientation, updatedDimensions, quality)\n    })\n    .catch((customError) => {\n      const buffer = customError.buffer\n      delete customError.buffer\n      if (!hasCallback) {\n        throw customError\n      }\n      callback(customError, buffer, null, null, null)\n    })\n  if (!hasCallback) {\n    return promise\n  }\n}\n\n/**\n * Transform the given input to a buffer\n * (May be a string or a buffer)\n */\nfunction readBuffer(pathOrBuffer) {\n  if (typeof pathOrBuffer === 'string') {\n    return promisify(fs.readFile)(pathOrBuffer).catch((error) => {\n      throw new CustomError(m.errors.read_file, 'Could not read file (' + error.message + ')')\n    })\n  }\n  if (typeof pathOrBuffer === 'object' && Buffer.isBuffer(pathOrBuffer)) {\n    return Promise.resolve(pathOrBuffer)\n  }\n  return Promise.reject(new CustomError(m.errors.read_file, 'Not a file path or buffer'))\n}\n\nfunction readExifFromBuffer(buffer) {\n  let exifData = null\n  try {\n    exifData = piexif.load(buffer.toString('binary'))\n  } catch (error) {\n    return Promise.reject(new CustomError(m.errors.read_exif, 'Could not read EXIF data (' + error + ')'))\n  }\n  return Promise.resolve({buffer, exifData})\n}\n\n/**\n * Extract the orientation tag from the given EXIF data\n */\nfunction parseOrientationTag({buffer, exifData}) {\n  let orientation = null\n  if (exifData['0th'] && exifData['0th'][piexif.ImageIFD.Orientation]) {\n    orientation = parseInt(exifData['0th'][piexif.ImageIFD.Orientation])\n  }\n  if (orientation === null) {\n    throw new CustomError(m.errors.no_orientation, 'No orientation tag found in EXIF', buffer)\n  }\n  if (isNaN(orientation) || orientation < 1 || orientation > 8) {\n    throw new CustomError(m.errors.unknown_orientation, 'Unknown orientation (' + orientation + ')', buffer)\n  }\n  if (orientation === 1) {\n    throw new CustomError(m.errors.correct_orientation, 'Orientation already correct', buffer)\n  }\n  return orientation\n}\n\nfunction rotateImage(buffer, orientation, quality, maxResolutionInMP, maxMemoryUsageInMB) {\n  return rotateBuffer(buffer, orientation, quality, maxResolutionInMP, maxMemoryUsageInMB).catch((error) => {\n    throw new CustomError(m.errors.rotate_file, 'Could not rotate image (' + error.message + ')', buffer)\n  })\n}\n\nfunction rotateThumbnail(buffer, exifData, orientation, quality, maxResolutionInMP, maxMemoryUsageInMB) {\n  if (typeof exifData['thumbnail'] === 'undefined' || exifData['thumbnail'] === null) {\n    return Promise.resolve({})\n  }\n  return rotateBuffer(\n    Buffer.from(exifData['thumbnail'], 'binary'),\n    orientation,\n    quality,\n    maxResolutionInMP,\n    maxMemoryUsageInMB\n  ).catch((error) => {\n    throw new CustomError(m.errors.rotate_file, 'Could not rotate thumbnail (' + error.message + ')', buffer)\n  })\n}\n\n/**\n * Compute the final buffer by updating the original EXIF data and linking it to the rotated buffer\n */\nfunction computeFinalBuffer(image, thumbnail, exifData, orientation) {\n  exifData['0th'][piexif.ImageIFD.Orientation] = 1\n  if (typeof exifData['Exif'][piexif.ExifIFD.PixelXDimension] !== 'undefined') {\n    exifData['Exif'][piexif.ExifIFD.PixelXDimension] = image.width\n  }\n  if (typeof exifData['Exif'][piexif.ExifIFD.PixelYDimension] !== 'undefined') {\n    exifData['Exif'][piexif.ExifIFD.PixelYDimension] = image.height\n  }\n  if (thumbnail.buffer) {\n    exifData['thumbnail'] = thumbnail.buffer.toString('binary')\n  }\n  const exifBytes = piexif.dump(exifData)\n  const updatedBuffer = Buffer.from(piexif.insert(exifBytes, image.buffer.toString('binary')), 'binary')\n  const updatedDimensions = {\n    height: image.height,\n    width: image.width,\n  }\n  return Promise.resolve({updatedBuffer, orientation, updatedDimensions})\n}\n\nmodule.exports = m\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanBlZy1hdXRvcm90YXRlL3NyYy9tYWluLmpzIiwibWFwcGluZ3MiOiJBQUFBLG9CQUFvQixtQkFBTyxDQUFDLGlGQUFrQjtBQUM5QyxxQkFBcUIsaUhBQXNDO0FBQzNELFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGVBQWUsbUJBQU8sQ0FBQyx5REFBVTtBQUNqQyxrQkFBa0IsbURBQXlCOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QiwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLFlBQVksOENBQThDO0FBQzFEO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQThDO0FBQ3hFOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMveW9zaGkvRGVza3RvcC9zdWJ0aXRsZS10cmFuc2xhdG9yL25vZGVfbW9kdWxlcy9qcGVnLWF1dG9yb3RhdGUvc3JjL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ3VzdG9tRXJyb3IgPSByZXF1aXJlKCcuL2N1c3RvbWVycm9yLmpzJylcbmNvbnN0IHJvdGF0ZUJ1ZmZlciA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtLmpzJykucm90YXRlQnVmZmVyXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHBpZXhpZiA9IHJlcXVpcmUoJ3BpZXhpZmpzJylcbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3V0aWwnKS5wcm9taXNpZnlcblxuY29uc3QgbSA9IHt9XG5cbm0uZXJyb3JzID0ge1xuICByZWFkX2ZpbGU6ICdyZWFkX2ZpbGUnLFxuICByZWFkX2V4aWY6ICdyZWFkX2V4aWYnLFxuICBub19vcmllbnRhdGlvbjogJ25vX29yaWVudGF0aW9uJyxcbiAgdW5rbm93bl9vcmllbnRhdGlvbjogJ3Vua25vd25fb3JpZW50YXRpb24nLFxuICBjb3JyZWN0X29yaWVudGF0aW9uOiAnY29ycmVjdF9vcmllbnRhdGlvbicsXG4gIHJvdGF0ZV9maWxlOiAncm90YXRlX2ZpbGUnLFxufVxuXG4vKipcbiAqIFJlYWQgdGhlIGlucHV0LCByb3RhdGUgdGhlIGltYWdlLCByZXR1cm4gdGhlIHJlc3VsdCAodXBkYXRlZCBidWZmZXIsIGRpbWVuc2lvbnMsIGV0YylcbiAqL1xubS5yb3RhdGUgPSBmdW5jdGlvbiAocGF0aE9yQnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBjb25zdCBoYXNDYWxsYmFjayA9IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJ1xuICBjb25zdCBxdWFsaXR5ID1cbiAgICB0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiZcbiAgICBvcHRzICE9PSBudWxsICYmXG4gICAgdHlwZW9mIG9wdHMucXVhbGl0eSA9PT0gJ251bWJlcicgJiZcbiAgICBvcHRzLnF1YWxpdHkgPiAwICYmXG4gICAgb3B0cy5xdWFsaXR5IDw9IDEwMFxuICAgICAgPyBvcHRzLnF1YWxpdHlcbiAgICAgIDogMTAwXG4gIGNvbnN0IG1heFJlc29sdXRpb25Jbk1QID1cbiAgICB0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiZcbiAgICBvcHRzICE9PSBudWxsICYmXG4gICAgdHlwZW9mIG9wdHMuanBlZ2pzTWF4UmVzb2x1dGlvbkluTVAgPT09ICdudW1iZXInICYmXG4gICAgb3B0cy5qcGVnanNNYXhSZXNvbHV0aW9uSW5NUCA+IDBcbiAgICAgID8gb3B0cy5qcGVnanNNYXhSZXNvbHV0aW9uSW5NUFxuICAgICAgOiBudWxsXG4gIGNvbnN0IG1heE1lbW9yeVVzYWdlSW5NQiA9XG4gICAgdHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmXG4gICAgb3B0cyAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiBvcHRzLmpwZWdqc01heE1lbW9yeVVzYWdlSW5NQiA9PT0gJ251bWJlcicgJiZcbiAgICBvcHRzLmpwZWdqc01heE1lbW9yeVVzYWdlSW5NQiA+IDBcbiAgICAgID8gb3B0cy5qcGVnanNNYXhNZW1vcnlVc2FnZUluTUJcbiAgICAgIDogbnVsbFxuICBjb25zdCBwcm9taXNlID0gcmVhZEJ1ZmZlcihwYXRoT3JCdWZmZXIpXG4gICAgLnRoZW4ocmVhZEV4aWZGcm9tQnVmZmVyKVxuICAgIC50aGVuKCh7YnVmZmVyLCBleGlmRGF0YX0pID0+IHtcbiAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gcGFyc2VPcmllbnRhdGlvblRhZyh7YnVmZmVyLCBleGlmRGF0YX0pXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICByb3RhdGVJbWFnZShidWZmZXIsIG9yaWVudGF0aW9uLCBxdWFsaXR5LCBtYXhSZXNvbHV0aW9uSW5NUCwgbWF4TWVtb3J5VXNhZ2VJbk1CKSxcbiAgICAgICAgcm90YXRlVGh1bWJuYWlsKGJ1ZmZlciwgZXhpZkRhdGEsIG9yaWVudGF0aW9uLCBxdWFsaXR5LCBtYXhSZXNvbHV0aW9uSW5NUCwgbWF4TWVtb3J5VXNhZ2VJbk1CKSxcbiAgICAgIF0pLnRoZW4oKFtpbWFnZSwgdGh1bWJuYWlsXSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tcHV0ZUZpbmFsQnVmZmVyKGltYWdlLCB0aHVtYm5haWwsIGV4aWZEYXRhLCBvcmllbnRhdGlvbilcbiAgICAgIH0pXG4gICAgfSlcbiAgICAudGhlbigoe3VwZGF0ZWRCdWZmZXIsIG9yaWVudGF0aW9uLCB1cGRhdGVkRGltZW5zaW9uc30pID0+IHtcbiAgICAgIGlmICghaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHtidWZmZXI6IHVwZGF0ZWRCdWZmZXIsIG9yaWVudGF0aW9uLCBkaW1lbnNpb25zOiB1cGRhdGVkRGltZW5zaW9ucywgcXVhbGl0eX1cbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIHVwZGF0ZWRCdWZmZXIsIG9yaWVudGF0aW9uLCB1cGRhdGVkRGltZW5zaW9ucywgcXVhbGl0eSlcbiAgICB9KVxuICAgIC5jYXRjaCgoY3VzdG9tRXJyb3IpID0+IHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGN1c3RvbUVycm9yLmJ1ZmZlclxuICAgICAgZGVsZXRlIGN1c3RvbUVycm9yLmJ1ZmZlclxuICAgICAgaWYgKCFoYXNDYWxsYmFjaykge1xuICAgICAgICB0aHJvdyBjdXN0b21FcnJvclxuICAgICAgfVxuICAgICAgY2FsbGJhY2soY3VzdG9tRXJyb3IsIGJ1ZmZlciwgbnVsbCwgbnVsbCwgbnVsbClcbiAgICB9KVxuICBpZiAoIWhhc0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZ2l2ZW4gaW5wdXQgdG8gYSBidWZmZXJcbiAqIChNYXkgYmUgYSBzdHJpbmcgb3IgYSBidWZmZXIpXG4gKi9cbmZ1bmN0aW9uIHJlYWRCdWZmZXIocGF0aE9yQnVmZmVyKSB7XG4gIGlmICh0eXBlb2YgcGF0aE9yQnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwcm9taXNpZnkoZnMucmVhZEZpbGUpKHBhdGhPckJ1ZmZlcikuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgQ3VzdG9tRXJyb3IobS5lcnJvcnMucmVhZF9maWxlLCAnQ291bGQgbm90IHJlYWQgZmlsZSAoJyArIGVycm9yLm1lc3NhZ2UgKyAnKScpXG4gICAgfSlcbiAgfVxuICBpZiAodHlwZW9mIHBhdGhPckJ1ZmZlciA9PT0gJ29iamVjdCcgJiYgQnVmZmVyLmlzQnVmZmVyKHBhdGhPckJ1ZmZlcikpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBhdGhPckJ1ZmZlcilcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEN1c3RvbUVycm9yKG0uZXJyb3JzLnJlYWRfZmlsZSwgJ05vdCBhIGZpbGUgcGF0aCBvciBidWZmZXInKSlcbn1cblxuZnVuY3Rpb24gcmVhZEV4aWZGcm9tQnVmZmVyKGJ1ZmZlcikge1xuICBsZXQgZXhpZkRhdGEgPSBudWxsXG4gIHRyeSB7XG4gICAgZXhpZkRhdGEgPSBwaWV4aWYubG9hZChidWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQ3VzdG9tRXJyb3IobS5lcnJvcnMucmVhZF9leGlmLCAnQ291bGQgbm90IHJlYWQgRVhJRiBkYXRhICgnICsgZXJyb3IgKyAnKScpKVxuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoe2J1ZmZlciwgZXhpZkRhdGF9KVxufVxuXG4vKipcbiAqIEV4dHJhY3QgdGhlIG9yaWVudGF0aW9uIHRhZyBmcm9tIHRoZSBnaXZlbiBFWElGIGRhdGFcbiAqL1xuZnVuY3Rpb24gcGFyc2VPcmllbnRhdGlvblRhZyh7YnVmZmVyLCBleGlmRGF0YX0pIHtcbiAgbGV0IG9yaWVudGF0aW9uID0gbnVsbFxuICBpZiAoZXhpZkRhdGFbJzB0aCddICYmIGV4aWZEYXRhWycwdGgnXVtwaWV4aWYuSW1hZ2VJRkQuT3JpZW50YXRpb25dKSB7XG4gICAgb3JpZW50YXRpb24gPSBwYXJzZUludChleGlmRGF0YVsnMHRoJ11bcGlleGlmLkltYWdlSUZELk9yaWVudGF0aW9uXSlcbiAgfVxuICBpZiAob3JpZW50YXRpb24gPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgQ3VzdG9tRXJyb3IobS5lcnJvcnMubm9fb3JpZW50YXRpb24sICdObyBvcmllbnRhdGlvbiB0YWcgZm91bmQgaW4gRVhJRicsIGJ1ZmZlcilcbiAgfVxuICBpZiAoaXNOYU4ob3JpZW50YXRpb24pIHx8IG9yaWVudGF0aW9uIDwgMSB8fCBvcmllbnRhdGlvbiA+IDgpIHtcbiAgICB0aHJvdyBuZXcgQ3VzdG9tRXJyb3IobS5lcnJvcnMudW5rbm93bl9vcmllbnRhdGlvbiwgJ1Vua25vd24gb3JpZW50YXRpb24gKCcgKyBvcmllbnRhdGlvbiArICcpJywgYnVmZmVyKVxuICB9XG4gIGlmIChvcmllbnRhdGlvbiA9PT0gMSkge1xuICAgIHRocm93IG5ldyBDdXN0b21FcnJvcihtLmVycm9ycy5jb3JyZWN0X29yaWVudGF0aW9uLCAnT3JpZW50YXRpb24gYWxyZWFkeSBjb3JyZWN0JywgYnVmZmVyKVxuICB9XG4gIHJldHVybiBvcmllbnRhdGlvblxufVxuXG5mdW5jdGlvbiByb3RhdGVJbWFnZShidWZmZXIsIG9yaWVudGF0aW9uLCBxdWFsaXR5LCBtYXhSZXNvbHV0aW9uSW5NUCwgbWF4TWVtb3J5VXNhZ2VJbk1CKSB7XG4gIHJldHVybiByb3RhdGVCdWZmZXIoYnVmZmVyLCBvcmllbnRhdGlvbiwgcXVhbGl0eSwgbWF4UmVzb2x1dGlvbkluTVAsIG1heE1lbW9yeVVzYWdlSW5NQikuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgbmV3IEN1c3RvbUVycm9yKG0uZXJyb3JzLnJvdGF0ZV9maWxlLCAnQ291bGQgbm90IHJvdGF0ZSBpbWFnZSAoJyArIGVycm9yLm1lc3NhZ2UgKyAnKScsIGJ1ZmZlcilcbiAgfSlcbn1cblxuZnVuY3Rpb24gcm90YXRlVGh1bWJuYWlsKGJ1ZmZlciwgZXhpZkRhdGEsIG9yaWVudGF0aW9uLCBxdWFsaXR5LCBtYXhSZXNvbHV0aW9uSW5NUCwgbWF4TWVtb3J5VXNhZ2VJbk1CKSB7XG4gIGlmICh0eXBlb2YgZXhpZkRhdGFbJ3RodW1ibmFpbCddID09PSAndW5kZWZpbmVkJyB8fCBleGlmRGF0YVsndGh1bWJuYWlsJ10gPT09IG51bGwpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KVxuICB9XG4gIHJldHVybiByb3RhdGVCdWZmZXIoXG4gICAgQnVmZmVyLmZyb20oZXhpZkRhdGFbJ3RodW1ibmFpbCddLCAnYmluYXJ5JyksXG4gICAgb3JpZW50YXRpb24sXG4gICAgcXVhbGl0eSxcbiAgICBtYXhSZXNvbHV0aW9uSW5NUCxcbiAgICBtYXhNZW1vcnlVc2FnZUluTUJcbiAgKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICB0aHJvdyBuZXcgQ3VzdG9tRXJyb3IobS5lcnJvcnMucm90YXRlX2ZpbGUsICdDb3VsZCBub3Qgcm90YXRlIHRodW1ibmFpbCAoJyArIGVycm9yLm1lc3NhZ2UgKyAnKScsIGJ1ZmZlcilcbiAgfSlcbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBmaW5hbCBidWZmZXIgYnkgdXBkYXRpbmcgdGhlIG9yaWdpbmFsIEVYSUYgZGF0YSBhbmQgbGlua2luZyBpdCB0byB0aGUgcm90YXRlZCBidWZmZXJcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZpbmFsQnVmZmVyKGltYWdlLCB0aHVtYm5haWwsIGV4aWZEYXRhLCBvcmllbnRhdGlvbikge1xuICBleGlmRGF0YVsnMHRoJ11bcGlleGlmLkltYWdlSUZELk9yaWVudGF0aW9uXSA9IDFcbiAgaWYgKHR5cGVvZiBleGlmRGF0YVsnRXhpZiddW3BpZXhpZi5FeGlmSUZELlBpeGVsWERpbWVuc2lvbl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhpZkRhdGFbJ0V4aWYnXVtwaWV4aWYuRXhpZklGRC5QaXhlbFhEaW1lbnNpb25dID0gaW1hZ2Uud2lkdGhcbiAgfVxuICBpZiAodHlwZW9mIGV4aWZEYXRhWydFeGlmJ11bcGlleGlmLkV4aWZJRkQuUGl4ZWxZRGltZW5zaW9uXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleGlmRGF0YVsnRXhpZiddW3BpZXhpZi5FeGlmSUZELlBpeGVsWURpbWVuc2lvbl0gPSBpbWFnZS5oZWlnaHRcbiAgfVxuICBpZiAodGh1bWJuYWlsLmJ1ZmZlcikge1xuICAgIGV4aWZEYXRhWyd0aHVtYm5haWwnXSA9IHRodW1ibmFpbC5idWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpXG4gIH1cbiAgY29uc3QgZXhpZkJ5dGVzID0gcGlleGlmLmR1bXAoZXhpZkRhdGEpXG4gIGNvbnN0IHVwZGF0ZWRCdWZmZXIgPSBCdWZmZXIuZnJvbShwaWV4aWYuaW5zZXJ0KGV4aWZCeXRlcywgaW1hZ2UuYnVmZmVyLnRvU3RyaW5nKCdiaW5hcnknKSksICdiaW5hcnknKVxuICBjb25zdCB1cGRhdGVkRGltZW5zaW9ucyA9IHtcbiAgICBoZWlnaHQ6IGltYWdlLmhlaWdodCxcbiAgICB3aWR0aDogaW1hZ2Uud2lkdGgsXG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7dXBkYXRlZEJ1ZmZlciwgb3JpZW50YXRpb24sIHVwZGF0ZWREaW1lbnNpb25zfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jpeg-autorotate/src/main.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jpeg-autorotate/src/transform.js":
/*!*******************************************************!*\
  !*** ./node_modules/jpeg-autorotate/src/transform.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const jpegjs = __webpack_require__(/*! jpeg-js */ \"(ssr)/./node_modules/jpeg-js/index.js\")\n\nconst m = {}\n\n/**\n * Decode the given buffer and applies the right transformation\n * Depending on the orientation, it may be a rotation and / or an horizontal flip\n */\nm.rotateBuffer = function (buffer, orientation, quality, maxResolutionInMP, maxMemoryUsageInMB) {\n  let jpeg = null\n  try {\n    const options = {}\n    if (maxResolutionInMP !== null) {\n      options.maxResolutionInMP = maxResolutionInMP\n    }\n    if (maxMemoryUsageInMB !== null) {\n      options.maxMemoryUsageInMB = maxMemoryUsageInMB\n    }\n    jpeg = jpegjs.decode(buffer, options)\n  } catch (error) {\n    return Promise.reject(error)\n  }\n  let newBuffer = jpeg.data\n\n  const transformations = {\n    2: {rotate: 0, flip: true},\n    3: {rotate: 180, flip: false},\n    4: {rotate: 180, flip: true},\n    5: {rotate: 90, flip: true},\n    6: {rotate: 90, flip: false},\n    7: {rotate: 270, flip: true},\n    8: {rotate: 270, flip: false},\n  }\n\n  if (transformations[orientation].rotate > 0) {\n    newBuffer = rotatePixels(newBuffer, jpeg.width, jpeg.height, transformations[orientation].rotate)\n  }\n\n  const ratioWillChange = (transformations[orientation].rotate / 90) % 2 === 1\n  const destWidth = ratioWillChange ? jpeg.height : jpeg.width\n  const destHeight = ratioWillChange ? jpeg.width : jpeg.height\n\n  if (transformations[orientation].flip) {\n    newBuffer = flipPixels(newBuffer, destWidth, destHeight)\n  }\n\n  const newJpeg = jpegjs.encode({data: newBuffer, width: destWidth, height: destHeight}, quality)\n  return Promise.resolve({buffer: newJpeg.data, width: destWidth, height: destHeight})\n}\n\n/**\n * Rotate a buffer (degrees must be a multiple of 90)\n * Inspired from Jimp (https://github.com/oliver-moran/jimp)\n */\nfunction rotatePixels(buffer, width, height, degrees) {\n  let loops = degrees / 90\n  while (loops > 0) {\n    const newBuffer = Buffer.alloc(buffer.length)\n    let newOffset = 0\n    for (let x = 0; x < width; x += 1) {\n      for (let y = height - 1; y >= 0; y -= 1) {\n        const offset = (width * y + x) << 2\n        const pixel = buffer.readUInt32BE(offset, true)\n        newBuffer.writeUInt32BE(pixel, newOffset, true)\n        newOffset += 4\n      }\n    }\n    buffer = newBuffer\n    const newHeight = width\n    width = height\n    height = newHeight\n    loops -= 1\n  }\n  return buffer\n}\n\n/**\n * Flip a buffer horizontally\n */\nfunction flipPixels(buffer, width, height) {\n  const newBuffer = Buffer.alloc(buffer.length)\n  for (let x = 0; x < width; x += 1) {\n    for (let y = 0; y < height; y += 1) {\n      const offset = (width * y + x) << 2\n      const newOffset = (width * y + width - 1 - x) << 2\n      const pixel = buffer.readUInt32BE(offset, true)\n      newBuffer.writeUInt32BE(pixel, newOffset, true)\n    }\n  }\n  return newBuffer\n}\n\nmodule.exports = m\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanBlZy1hdXRvcm90YXRlL3NyYy90cmFuc2Zvcm0uanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLHNEQUFTOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxzQkFBc0I7QUFDOUIsUUFBUSx5QkFBeUI7QUFDakMsUUFBUSx3QkFBd0I7QUFDaEMsUUFBUSx1QkFBdUI7QUFDL0IsUUFBUSx3QkFBd0I7QUFDaEMsUUFBUSx3QkFBd0I7QUFDaEMsUUFBUSx5QkFBeUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHNEQUFzRDtBQUN2RiwwQkFBMEIsMkRBQTJEO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy95b3NoaS9EZXNrdG9wL3N1YnRpdGxlLXRyYW5zbGF0b3Ivbm9kZV9tb2R1bGVzL2pwZWctYXV0b3JvdGF0ZS9zcmMvdHJhbnNmb3JtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGpwZWdqcyA9IHJlcXVpcmUoJ2pwZWctanMnKVxuXG5jb25zdCBtID0ge31cblxuLyoqXG4gKiBEZWNvZGUgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgYXBwbGllcyB0aGUgcmlnaHQgdHJhbnNmb3JtYXRpb25cbiAqIERlcGVuZGluZyBvbiB0aGUgb3JpZW50YXRpb24sIGl0IG1heSBiZSBhIHJvdGF0aW9uIGFuZCAvIG9yIGFuIGhvcml6b250YWwgZmxpcFxuICovXG5tLnJvdGF0ZUJ1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXIsIG9yaWVudGF0aW9uLCBxdWFsaXR5LCBtYXhSZXNvbHV0aW9uSW5NUCwgbWF4TWVtb3J5VXNhZ2VJbk1CKSB7XG4gIGxldCBqcGVnID0gbnVsbFxuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7fVxuICAgIGlmIChtYXhSZXNvbHV0aW9uSW5NUCAhPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5tYXhSZXNvbHV0aW9uSW5NUCA9IG1heFJlc29sdXRpb25Jbk1QXG4gICAgfVxuICAgIGlmIChtYXhNZW1vcnlVc2FnZUluTUIgIT09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMubWF4TWVtb3J5VXNhZ2VJbk1CID0gbWF4TWVtb3J5VXNhZ2VJbk1CXG4gICAgfVxuICAgIGpwZWcgPSBqcGVnanMuZGVjb2RlKGJ1ZmZlciwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpXG4gIH1cbiAgbGV0IG5ld0J1ZmZlciA9IGpwZWcuZGF0YVxuXG4gIGNvbnN0IHRyYW5zZm9ybWF0aW9ucyA9IHtcbiAgICAyOiB7cm90YXRlOiAwLCBmbGlwOiB0cnVlfSxcbiAgICAzOiB7cm90YXRlOiAxODAsIGZsaXA6IGZhbHNlfSxcbiAgICA0OiB7cm90YXRlOiAxODAsIGZsaXA6IHRydWV9LFxuICAgIDU6IHtyb3RhdGU6IDkwLCBmbGlwOiB0cnVlfSxcbiAgICA2OiB7cm90YXRlOiA5MCwgZmxpcDogZmFsc2V9LFxuICAgIDc6IHtyb3RhdGU6IDI3MCwgZmxpcDogdHJ1ZX0sXG4gICAgODoge3JvdGF0ZTogMjcwLCBmbGlwOiBmYWxzZX0sXG4gIH1cblxuICBpZiAodHJhbnNmb3JtYXRpb25zW29yaWVudGF0aW9uXS5yb3RhdGUgPiAwKSB7XG4gICAgbmV3QnVmZmVyID0gcm90YXRlUGl4ZWxzKG5ld0J1ZmZlciwganBlZy53aWR0aCwganBlZy5oZWlnaHQsIHRyYW5zZm9ybWF0aW9uc1tvcmllbnRhdGlvbl0ucm90YXRlKVxuICB9XG5cbiAgY29uc3QgcmF0aW9XaWxsQ2hhbmdlID0gKHRyYW5zZm9ybWF0aW9uc1tvcmllbnRhdGlvbl0ucm90YXRlIC8gOTApICUgMiA9PT0gMVxuICBjb25zdCBkZXN0V2lkdGggPSByYXRpb1dpbGxDaGFuZ2UgPyBqcGVnLmhlaWdodCA6IGpwZWcud2lkdGhcbiAgY29uc3QgZGVzdEhlaWdodCA9IHJhdGlvV2lsbENoYW5nZSA/IGpwZWcud2lkdGggOiBqcGVnLmhlaWdodFxuXG4gIGlmICh0cmFuc2Zvcm1hdGlvbnNbb3JpZW50YXRpb25dLmZsaXApIHtcbiAgICBuZXdCdWZmZXIgPSBmbGlwUGl4ZWxzKG5ld0J1ZmZlciwgZGVzdFdpZHRoLCBkZXN0SGVpZ2h0KVxuICB9XG5cbiAgY29uc3QgbmV3SnBlZyA9IGpwZWdqcy5lbmNvZGUoe2RhdGE6IG5ld0J1ZmZlciwgd2lkdGg6IGRlc3RXaWR0aCwgaGVpZ2h0OiBkZXN0SGVpZ2h0fSwgcXVhbGl0eSlcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7YnVmZmVyOiBuZXdKcGVnLmRhdGEsIHdpZHRoOiBkZXN0V2lkdGgsIGhlaWdodDogZGVzdEhlaWdodH0pXG59XG5cbi8qKlxuICogUm90YXRlIGEgYnVmZmVyIChkZWdyZWVzIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA5MClcbiAqIEluc3BpcmVkIGZyb20gSmltcCAoaHR0cHM6Ly9naXRodWIuY29tL29saXZlci1tb3Jhbi9qaW1wKVxuICovXG5mdW5jdGlvbiByb3RhdGVQaXhlbHMoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBkZWdyZWVzKSB7XG4gIGxldCBsb29wcyA9IGRlZ3JlZXMgLyA5MFxuICB3aGlsZSAobG9vcHMgPiAwKSB7XG4gICAgY29uc3QgbmV3QnVmZmVyID0gQnVmZmVyLmFsbG9jKGJ1ZmZlci5sZW5ndGgpXG4gICAgbGV0IG5ld09mZnNldCA9IDBcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4ICs9IDEpIHtcbiAgICAgIGZvciAobGV0IHkgPSBoZWlnaHQgLSAxOyB5ID49IDA7IHkgLT0gMSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAod2lkdGggKiB5ICsgeCkgPDwgMlxuICAgICAgICBjb25zdCBwaXhlbCA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0LCB0cnVlKVxuICAgICAgICBuZXdCdWZmZXIud3JpdGVVSW50MzJCRShwaXhlbCwgbmV3T2Zmc2V0LCB0cnVlKVxuICAgICAgICBuZXdPZmZzZXQgKz0gNFxuICAgICAgfVxuICAgIH1cbiAgICBidWZmZXIgPSBuZXdCdWZmZXJcbiAgICBjb25zdCBuZXdIZWlnaHQgPSB3aWR0aFxuICAgIHdpZHRoID0gaGVpZ2h0XG4gICAgaGVpZ2h0ID0gbmV3SGVpZ2h0XG4gICAgbG9vcHMgLT0gMVxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuLyoqXG4gKiBGbGlwIGEgYnVmZmVyIGhvcml6b250YWxseVxuICovXG5mdW5jdGlvbiBmbGlwUGl4ZWxzKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCkge1xuICBjb25zdCBuZXdCdWZmZXIgPSBCdWZmZXIuYWxsb2MoYnVmZmVyLmxlbmd0aClcbiAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCArPSAxKSB7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKz0gMSkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKHdpZHRoICogeSArIHgpIDw8IDJcbiAgICAgIGNvbnN0IG5ld09mZnNldCA9ICh3aWR0aCAqIHkgKyB3aWR0aCAtIDEgLSB4KSA8PCAyXG4gICAgICBjb25zdCBwaXhlbCA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0LCB0cnVlKVxuICAgICAgbmV3QnVmZmVyLndyaXRlVUludDMyQkUocGl4ZWwsIG5ld09mZnNldCwgdHJ1ZSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0J1ZmZlclxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jpeg-autorotate/src/transform.js\n");

/***/ })

};
;